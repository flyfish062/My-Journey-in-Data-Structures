

![回顾与总结](520D85D8BD0472637819651220781E42.png)

> 来自王卓数据结构课件

## 基本概念

**线性表是具有相同特性的数据元素的一个有限序列**

- 同一线性表中元素有相同特性
- 数据元素间的关系是线性关系


![基本概念](D7F117858389780C323BC425272F9577.png)
> 来自王卓数据结构课件

从具体应用中抽象出共性的逻辑结构和基本操作，然后实现储存结构和基本操作

## 线性表的类型定义

![定义](57EE867B0AD755C2834B729231A272FA.png)






## 线性表的顺序储存表示与实现

依次储存，地址连续，中间无空出储存单元，类型相同，随机存取

- 储存位置简单的计算


```c
//顺序线性表的模板
#define MAXSIZE 100
typedef struct{
   ElemType *elem 
   int length
}sqList
```


### 补充

![补充](4d83ca8a98cd79287fece9dd85d936be.png)


### 实现初始化
`InitList_sq`

```cpp
Status InitList_Sq(SqList &L){
L.elem = new ElemType[MaxSize];
if(!L.elem) exit(OVERFLOW)
L.length = 0;
return OK;
}
```

### 实现销毁
`DestroyList`
```cpp
void DestoryList(sqList &L){
  if(L.elem) delete L.elem;
}
```

### 实现清空
`ClearList`
```cpp
void ClearList(sqList &L){
  L.length =0;
}
```

### 返回长度
`GetLength`
```cpp
int GetLength(SqList L){
  return (L.length);
}
```

### 实现空的判断
`IsEmpty`
```cpp
int IsEmpty(SqList L){
  if(L.length ==0)return 1;
  else return 0;
}
```

### 获取指定元素
 `GetElem`
 ```cpp
 int GetElem(SqList L,int i.ElemType &e){
   if(i<1||i>L.length)return ERROR;
   e = L.elem[i-1];
   return OK;
 }
 ```

### 实现顺序查找 O(n)
`LocateElem`
```cpp
int LocateElem(SqList L,ElemType e){
  for(i=0;i<L.length;i++)
    if(L.elem[i]==e) return i+1;
    return 0;
}
```

**平均查找长度**：是确定元素表中位置，需要与给定值进行比较的关键字的个数的期望值

### 实现元素插入 O(n)
`ListInsert_Sq`
```cpp
Status ListInsert_Sq(SqList &L,int i,ElemType e){
  if(i<1||i>L.length+1)return ERROR;
  if(L.length==MAXSIZE)return ERROR;
  for(j=L.length-1;j>=i-1;j--)
    L.elem[j+1]=L.elem[j];
    L.elem[i-1]=e;
    L.length++;
    return OK;
}
```

### 实现元素删除 O(n)

```cpp
Status ListDelete_Sq(SqList &L,int i){
  if(i<1||i>L.length)return ERROR;
  for(j=i;j<=L.length-1;j++)
    L.elem[j-1]=L.elem[j];
    L.length--;
    return OK;
}
```

- 储存密度大，可以随机存取任一元素
- 插入/删除时要移动大量元素，浪费储存空间
- 静态储存，数据元素个数不能自由扩充