

![回顾与总结](520D85D8BD0472637819651220781E42.png)

> 来自王卓数据结构课件

## 基本概念

**线性表是具有相同特性的数据元素的一个有限序列**

- 同一线性表中元素有相同特性
- 数据元素间的关系是线性关系


![基本概念](D7F117858389780C323BC425272F9577.png)
> 来自王卓数据结构课件

从具体应用中抽象出共性的逻辑结构和基本操作，然后实现储存结构和基本操作

## 线性表的类型定义

![定义](57EE867B0AD755C2834B729231A272FA.png)






## 线性表的顺序储存表示与实现

依次储存，地址连续，中间无空出储存单元，类型相同，随机存取

- 储存位置简单的计算


```c
//顺序线性表的模板
#define MAXSIZE 100
typedef struct{
   ElemType *elem 
   int length
}sqList
```


### 补充

![补充](4d83ca8a98cd79287fece9dd85d936be%201.png)


### 实现初始化
`InitList_sq`

```cpp
Status InitList_Sq(SqList &L){
L.elem = new ElemType[MaxSize];
if(!L.elem) exit(OVERFLOW)
L.length = 0;
return OK;
}
```

### 实现销毁
`DestroyList`
```cpp
void DestoryList(sqList &L){
  if(L.elem) delete L.elem;
}
```

### 实现清空
`ClearList`
```cpp
void ClearList(sqList &L){
  L.length =0;
}
```

### 返回长度
`GetLength`
```cpp
int GetLength(SqList L){
  return (L.length);
}
```

### 实现空的判断
`IsEmpty`
```cpp
int IsEmpty(SqList L){
  if(L.length ==0)return 1;
  else return 0;
}
```

### 获取指定元素
 `GetElem`
 ```cpp
 int GetElem(SqList L,int i.ElemType &e){
   if(i<1||i>L.length)return ERROR;
   e = L.elem[i-1];
   return OK;
 }
 ```

### 实现顺序查找 O(n)
`LocateElem`
```cpp
int LocateElem(SqList L,ElemType e){
  for(i=0;i<L.length;i++)
    if(L.elem[i]==e) return i+1;
    return 0;
}
```

**平均查找长度**：是确定元素表中位置，需要与给定值进行比较的关键字的个数的期望值

### 实现元素插入 O(n)
`ListInsert_Sq`
```cpp
Status ListInsert_Sq(SqList &L,int i,ElemType e){
  if(i<1||i>L.length+1)return ERROR;
  if(L.length==MAXSIZE)return ERROR;
  for(j=L.length-1;j>=i-1;j--)
    L.elem[j+1]=L.elem[j];
    L.elem[i-1]=e;
    L.length++;
    return OK;
}
```

### 实现元素删除 O(n)

```cpp
Status ListDelete_Sq(SqList &L,int i){
  if(i<1||i>L.length)return ERROR;
  for(j=i;j<=L.length-1;j++)
    L.elem[j-1]=L.elem[j];
    L.length--;
    return OK;
}
```

- 储存密度大，可以随机存取任一元素
- 插入/删除时要移动大量元素，浪费储存空间
- 静态储存，数据元素个数不能自由扩充


## 线性表的链式储存表示与实现

结点在储存器中的位置是任意的，逻辑相邻的数据元素在物理上不一定相邻。

 **线性表的链式表示**又被称为**非顺序映像**/**链式映像**

### 相关概念

- 结点：数据元素的储存映像，由数据域域指针域两部分组成。
- 链表：n个结点由指针链组成（线性表的链式储存结构）
- 数据域：储存元素数值数据
- 指针域：储存直接后继结点的储存位置
- 单链表/线性链表：结点只有一个指针域的链表
- 双链表：结点有两个指针域的链表
- 循环链表：首尾相接的链表
- 头指针：指向链表中第一个结点的指针
- 首元结点：指链表中储存的第一个数据元素 `a1`的结点
- 头结点：在链表首元节点之前设置的一个结点 
   - 便于首元结点处理
   - 便于空表和非空表统一处理
   - 其中数据域可以不储存数据，也可以放附加信息
   - 此结点不能计入链表长度

|**特性**|**头指针 (Head Pointer)**|**头节点的指针 (Head Node's Next)**|
|---|---|---|
|**本质**|一个**指针变量**。|头节点（一个**结构体/对象**）内部的一个**成员**。|
|**存储位置**|独立于链表节点之外。|存储在头节点这个物理空间内。|
|**指向目标**|指向头节点（或第一个数据节点）。|指向第一个真正存数据的节点（首元节点）。|
|**存在意义**|标识链表的开始，是访问链表的唯一入口。|为了方便在链表头部进行插入和删除操作。|


**有头结点时，头指针指向头结点；无头节点时，头指针指向首元结点**

**表示空表**
- 无头节点时，头指针为空时表示空表
- 有头节点时，头结点的指针域为空时，表示空表

**特点**
- 存储位置任意，逻辑相邻但物理不相邻
- 采用顺序存取法：访问时依次向后顺序扫描结点进行查找

### 单链表（带头节点）
```c
typedef struct Lnode{
  ElemType data;
  struct Lnode *next;
}Lnode, *LinkList; //LinkList为指向Lnode的指针类型

//定义链表L
LinkList L;
//定义结点指针p
LNode *p;
```

**标准定义方式**
```c
typedef Struct{
  char num[8];
  char name[8];
  int score;
}ElemType;

typedef struct Lnode{
  ElemType data;
  struct Lnode *next
}Lnode,*LinkList;
```

## 单链表操作实现
下面的数据定义参考上面第一种定义方式

### 单链表初始化

- 生成新节点作为头节点，用头指针L指向头节点
- 将头结点的指针域置空 
`InitList_L`
```c

Status InitList_L(LinkList &L){
  L=new LNode;
  L->next=NULL;
  return OK;
}

```

### 实现对空的判断
`ListEmpty`
```c
int ListEmpty(LinkList L){
  if(L->next)
    return 0;
  else
    return 1;
} 
```

### 单链表销毁
头指针，头节点都被销毁
- 从头指针开始，依次释放结点
`DestoryList_L`
```c
 Status Destory_L(LinkList &L){
   Lnode *p;
   while(L){
     p=L;
     L=L->next;
     delete p;
   }
   return OK;
 }
```

### 清空单列表
- 链表仍存在，但链表中无元素（头指针和头节点仍在）
-  依次释放所有结点，将头节点执政域设置为空

```c
Status ClearList(LinkList &L){
  Lnode *p, *q;
  p=L->next;
  while(p){
    q=p->next;
    delete p;
    p=q;
  }
  L->next=NULL;
  return OK;
}
```

### 对链表长度进行计数
`ListLength_list`
```c
int ListLength_list(LinkList L){
  LinkList p;
  p=L->next;
  i=0;
  while(p){
    i++;
    p=p->next;
  }
  return i;
}
```

### 实现对特定位置元素的获取
`GetElem`
- 从第一个节点顺链扫描，用p指向当前扫描的节点，p=L->next。
- j为计数器，累计当前扫描过的节点数，j初值为1
- 当p扫描到下一节点，计算器j加1

```c
Status GetElem_L(LinkList_L,int i,ElemType &e){
  p=L->next;
  j=1;
  while(p&&j<i){
    p=p->next;
    ++j;
  }
	if(!p||j>i) return ERROR;
	e=p->data;
	return OK;
}
```

### 按值查找 0(n)
`LocateElem_L`
```c
//返回地址
Lnode *LocateElem_L(LinkList L,Elemtype e){
  p=L->next;
  while(p && p->data!=e)
    p=p->next;
    return p;
}
//返回位置序号
int LocateElem_L(LinkList L, Elemtype e){
 p=L->next;j=1;
 while(p&&p->data!=e)
   {p=p->next;j++}
 if(p)return j;
 else return 0;
}
```

### 实现插入 O(1)已知位置
`ListInsert`
```c
//在L中第i个元素前插入数据元素e
Status ListInsert_L(LinkList &L,ElemType e){
 p=L;j=0;
 while(p&&j<i-1){p=p->next;++j;}
 if(!p||j>i-1)return ERROR;
 
 s=new LNode;
 s->data=e;
 
 s->next=p->next;
 p->next=s;
 return OK;
}
```

### 实现删除节点 O(1)已知位置
`ListDelete_L`
```c
Status ListDelete_L(LinkList &L,int i,ElemType &e){
p=L;j=0;
while(p->next&&j<i-1){p=p->next;++j}
if(!(p->next)||j>i-1)return ERROR;
  q=p->next;
  p->next=q->next;
  e=q->data;
  delete q;
return OK;
}
```

### 单链表的建立----头插法
`CreateList_H`
- 从空表开始，重复读入数据
- 生成新节点，将读入的数据存放到新节点的数据域中
- 从最后一个节点开始，依次将个节点插入链表前端

```c
void CreateList_H(LinkList &L,int n){
  L=new LNode;
  L->next=NULL;
  for(i=n;i>0;--i){
    p=new LNode;
    cin>>p->data;
    p->next=L->next;
    L->next=p;
  }
}
```

### 单链表的建立---后插法
- 从一个空表 L 开始，将新结点逐个插入到链表的尾部，尾指针 r 指向链表的尾结点。 
- 初始时，r 和 L 均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r 指向新结点。
```c
void CreateList_R(LinkList &L,int n){
  L=new LNode;
  L->next=NULL;
  r=L;
  for(i=0;i<n;++i){
    p=new LNode;
    cin>>p->data;
    p->next=NULL;
    r->next=p;
    r=p;
  }
}
```

## 循环链表

表中最后一个结点的指针域指向头节点，整个链表形成一个环

**从任意结点出发都可以找到其他的结点**

为空表时，头节点的指针域中存储了指向自己的指针。

### 带尾指针的循环链表合并
`Connect`
```c
LinkList Connect(LinkList Ta,LinkList Tb){
//Ta,Tb均为非空的单循环链表
  p=Ta->next;
  Ta->next=Tb->next;
  Tb-.next=p;
  return Tb;
}
```

## 双向链表
方便寻找前驱结点

在单链表的每个结点里再增加一个指向直接前驱的指针域，链表中形成有两个方向不同的链，称为双向链表
```c
typedef struct DuLNode{
  Elemtype data;
  struct DuLNode *prior,*next;
}DuLNode,*DuLinkList;
```

### 双向链表的插入
`ListInsert_DuL`
```c
void ListInsert_DuL(DuLinkList &L,int i,ElemType e){
  if(!(p=GetElemP_DuL(L,i))) return ERROR;
  s=new DuLNode;
  s->date=e;
  s->prior=p->prior;
  p->prior->next=s;
  s->next=p;
  p->prior=s;
  return OK;
}
```

### 双向链表的删除
`ListDelete_DuL`
```c
void ListDelete_DuL(DuLink &L,int i,ElemType &e){
  if(!(p=GeetElemP_DuL(L,i))) return ERROR;
  e=p->data;
  p->prior->next=p->next;
  p->next->prior=p->prior;
  free(p);
  return OK;
}
```

## 顺序表和链表的比较
**链式储存结构**
**优点**
- 结点空间可以动态实现申请和释放
- 数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素
**缺点**
- 储存密度小，每个结点指针域占用额外储存空间
- 存储密度=结点本身占用的空间/结点占用的空间总量
- 为非随机存取结构，对某个结点进行操作要从头遍历指针，增加算法复杂度

![比较](QQ20260207-124807.png)